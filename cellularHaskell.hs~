import Data.List
import System.Random
import Control.Monad

{-

-- COOL RULES --

3 ancestors:

73
99 -> steep shaded cone
105
109
118 -> shaded cone
120 (random init)
126 -> sierpinsky
129 -> inv. sierpinsky
131 -> inv. shaded cone
150
169
225

5 ancestors:

914134 -> pyramid
914138 -> sierpinsky wide
9141401 -> river
91415443 -> weird mountain

7 ancestors:

21133586
21133650 -> cliff

-}

ancestors :: Int
ancestors = 5

randomSimulation :: Int -> Int -> Int -> IO ()
randomSimulation len rule width = (fmap (showSimulation len rule) $ getRandomState width) >>= putStr

getRandomState :: Int -> IO [Bool]
getRandomState i = sequence $ replicate i $ randomRIO (False, True)

initState :: Int -> [Bool]
initState n = (replicate n False) ++ [True] ++ (replicate n False)

state :: [Bool]
state = initState 95

showSimulation :: Int -> Int -> [Bool] -> String
showSimulation len rule state = unlines $ map showState $ take len $ simulate rule state

simulate :: Int -> [Bool] -> [[Bool]]
simulate rule init = iterate (nextState rule) init

showState :: [Bool] -> String
showState = map f
  where f a = if a then 'x' else ' '

nextState :: Int -> [Bool] -> [Bool]
nextState rule current = map (translate $ decToBin rule) $ toNlets ancestors current

translate :: [Bool] -> [Bool] -> Bool
translate rule triplet = (reverse rule ++ repeat False) !! binToDec triplet

toNlets :: Int -> [a] -> [[a]]
toNlets n a =
  let
    wrapped = wrap ((n-1) `quot` 2) a
    len = length a
  in
    transpose $ map (take len) $ map (\x -> drop x wrapped) [0..(n-1)]

wrap :: Int -> [a] -> [a]
wrap n a = (drop (len - n) a) ++ a ++ (take n a)
  where len = length a

decToBin :: Int -> [Bool]
decToBin x = map (==1) $ reverse $ decToBin' x
  where
    decToBin' 0 = []
    decToBin' y =
      let (a,b) = y `quotRem` 2
      in [b] ++ decToBin' a

binToDec :: [Bool] -> Int
binToDec x = foldl f 0 x
  where
    f acc e = acc * 2 + if e then 1 else 0

lpad :: a -> Int -> [a] -> [a]
lpad x len xs = replicate (len - length xs) x ++ xs
